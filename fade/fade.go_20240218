package main

import (
//    "fmt"
    "image"
    "image/color"
    "image/draw"
//    "image/png"
    "log"
    "math"
//    "os"
    "time"
    "periph.io/x/host/v3"
//    "periph.io/x/conn/v3/driver/driverreg"
    "periph.io/x/conn/v3/physic"
    "periph.io/x/conn/v3/spi"
    "periph.io/x/conn/v3/spi/spireg"
    "github.com/stefan-muehlebach/gg/colornames"
)


type ColorType int

const (
    Red ColorType = iota
    Green
    Blue
    NumColors
)

// ledVal ist ein Slice von drei Arrays, resp. Slices, welche fuer die
// Farbkorrektur benoetigt werden. Es hat sich gezeigt, dass die Farbwerte
// fuer rot, gruen und blau in den LEDs nicht linear verwendet werden sollten.
var (
    ledVal [][]uint8
)

// In dieser Funktion werden die Korrektur-Arrays noch vor dem Start des
// eigenentlichen Programms aufgebaut. Man koennte zwar jede Farbe nach
// einer individuellen Kurve korrigieren, aber aktuell wird dieses Feature
// nicht verwendet, d.h. alle Korrektur-Slices sind mit den gleichen Werten
// versehen.
func init() {
    ledVal = make([][]uint8, NumColors)
    for i:=0; i<int(NumColors); i++ {
	ledVal[i] = make([]uint8, 256)
	for j:=0; j<256; j++ {
	    t := float64(j)/float64(255)
	    f := math.Pow(t, 2.0)
	    ledVal[i][j] = uint8(255.0 * f)
	}
    }
}

// Dieser Typ wird fuer die Farbwerte verwendet, welche via SPI zu den LED's
// gesendet werden.
type LedColor struct {
    R, G, B uint8
}

func (c LedColor) RGB() (r, g, b uint8) {
    return ledVal[Red][c.R], ledVal[Green][c.G], ledVal[Blue][c.B]
}

var (
    LedColorModel color.Model = color.ModelFunc(ledColorModel)
)

func ledColorModel(c color.Color) (color.Color) {
    if _, ok := c.(LedColor); ok {
        return c
    }
    r, g, b, _ := c.RGBA()
    return LedColor{ledVal[Red][r >> 8], ledVal[Green][g >> 8],
            ledVal[Blue][b >> 8]}
}

func (c LedColor) RGBA() (r, g, b, a uint32) {
    r, g, b = uint32(c.R), uint32(c.G), uint32(c.B)
    r |= r << 8
    g |= g << 8
    b |= b << 8
    a = 65535
    return
}

// Sollte die Interfaces image.Image und draw.Image implementieren, konkret:
//
//   - ColorModel() (color.Model)
//   - Bounds() (Rectangle)
//   - At(x, y int) (color.Color)
//   - Set(x, y int, c color.Color)
//
type LedGrid struct {
    Rect image.Rectangle
    //leds [][]LedColor
    Pix []uint8
}

func NewLedGrid(r image.Rectangle) (*LedGrid) {
    g := &LedGrid{}
    g.Rect = r
    //g.leds = make([][]LedColor, r.Dy())
    //for y:=0; y<r.Dy(); y++ {
//	g.leds[y] = make([]LedColor, r.Dx())
//	for x:=0; x<r.Dx(); x++ {
//	    g.leds[y][x] = LedColor{}
//	}
 //   }
    g.Pix = make([]uint8, 3 * r.Dx() * r.Dy())
    return g
}

func (g *LedGrid) ColorModel() (color.Model) {
    return LedColorModel
}

func (g *LedGrid) Bounds() (image.Rectangle) {
    return g.Rect
}

func (g *LedGrid) At(x, y int) (color.Color) {
    return g.LedColorAt(x, y)
}

func (g *LedGrid) LedColorAt(x, y int) (LedColor) {
    if !(image.Point{x, y}.In(g.Rect)) {
	return LedColor{}
    }
    i := g.PixOffset(x, y)
    s := g.Pix[i : i+3 : i+3]
    return LedColor{s[0], s[1], s[2]}
}

func (g *LedGrid) Set(x, y int, c color.Color) {
    c1 := LedColorModel.Convert(c).(LedColor)
    g.SetLedColor(x, y, c1)
}

func (g *LedGrid) SetLedColor(x, y int, c LedColor) {
    if !(image.Point{x, y}.In(g.Rect)) {
	return
    }
    //g.leds[y][x] = c
    i := g.PixOffset(x, y)
    s := g.Pix[i : i+3 : i+3]
    s[0] = c.R
    s[1] = c.G
    s[2] = c.B
}

func (g *LedGrid) PixOffset(x, y int) (int) {
    var idx int

    idx = y * g.Rect.Dx()
    if y % 2 == 1 {
        idx += x
    } else {
        idx += (g.Rect.Dx() - x - 1)
    }
    return 3*idx
}

var (
    SpiDevFile string           = "/dev/spidev0.0"
    SpiSpeedHz physic.Frequency = 4_000_000
    Width = 10
    Height = 10
)

func main() {
    var err error
//    var driverStates *driverreg.State
    var port spi.PortCloser
    var conn spi.Conn
    var ledGrid *LedGrid
    var img *image.RGBA
    //var fh *os.File
    var uniColor *image.Uniform

    ledGrid = NewLedGrid(image.Rect(0, 0, Width, Height))

    img = image.NewRGBA(image.Rect(0, 0, Width, Height))
    //fh, _ = os.Open("image.png")
    //img, _ = png.Decode(fh)

    uniColor = image.NewUniform(colornames.Black)

    if _, err = host.Init(); err != nil {
	log.Fatalf("host.Init(): %v", err)
    }
//    for _, drv := range driverStates.Loaded {
//	log.Printf("Driver loaded: %s", drv.String())
//    }
    
    if port, err = spireg.Open(SpiDevFile); err != nil {
	log.Fatalf("spireg.Open(): %v", err)
    }
    defer port.Close()
    if conn, err = port.Connect(SpiSpeedHz * physic.Hertz, spi.Mode0, 8);
            err != nil {
	log.Fatalf("port.Connect(): %v", err)
    }

    for _, colorName := range colornames.Groups[colornames.Greens] {
        log.Printf("[%s]", colorName)
        c := colornames.Map[colorName]
        for row:=0; row<img.Bounds().Dy(); row++ {
            //y := float64(row)/float64(img.Bounds().Dy()-1)
            for col:=0; col<img.Bounds().Dx(); col++ {
                x := float64(col)/float64(img.Bounds().Dx()-1)
                img.Set(col, row, c.Dark(x))
            }
        }
        draw.Draw(ledGrid, ledGrid.Bounds(), img, image.Point{}, draw.Src)
        conn.Tx(ledGrid.Pix, nil)
        time.Sleep(1000 * time.Millisecond)
    }

    draw.Draw(ledGrid, ledGrid.Bounds(), uniColor, image.Point{}, draw.Src)
    conn.Tx(ledGrid.Pix, nil)
    time.Sleep(5 * time.Millisecond)
}

